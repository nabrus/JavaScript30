<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Array Cardio 💪</title>
</head>
<body>
  <p><em>Psst: have a look at the JavaScript Console</em> 💁</p>
  <script>
    // Get your shorts on - this is an array workout!
    // ## Array Cardio Day 1

    // Some data we can work with

    const inventors = [
      { first: 'Albert', last: 'Einstein', year: 1879, passed: 1955 },
      { first: 'Isaac', last: 'Newton', year: 1643, passed: 1727 },
      { first: 'Galileo', last: 'Galilei', year: 1564, passed: 1642 },
      { first: 'Marie', last: 'Curie', year: 1867, passed: 1934 },
      { first: 'Johannes', last: 'Kepler', year: 1571, passed: 1630 },
      { first: 'Nicolaus', last: 'Copernicus', year: 1473, passed: 1543 },
      { first: 'Max', last: 'Planck', year: 1858, passed: 1947 },
      { first: 'Katherine', last: 'Blodgett', year: 1898, passed: 1979 },
      { first: 'Ada', last: 'Lovelace', year: 1815, passed: 1852 },
      { first: 'Sarah E.', last: 'Goode', year: 1855, passed: 1905 },
      { first: 'Lise', last: 'Meitner', year: 1878, passed: 1968 },
      { first: 'Hanna', last: 'Hammarström', year: 1829, passed: 1909 }
    ];

    const people = ['Beck, Glenn', 'Becker, Carl', 'Beckett, Samuel', 'Beddoes, Mick', 'Beecher, Henry', 'Beethoven, Ludwig', 'Begin, Menachem', 'Belloc, Hilaire', 'Bellow, Saul', 'Benchley, Robert', 'Benenson, Peter', 'Ben-Gurion, David', 'Benjamin, Walter', 'Benn, Tony', 'Bennington, Chester', 'Benson, Leana', 'Bent, Silas', 'Bentsen, Lloyd', 'Berger, Ric', 'Bergman, Ingmar', 'Berio, Luciano', 'Berle, Milton', 'Berlin, Irving', 'Berne, Eric', 'Bernhard, Sandra', 'Berra, Yogi', 'Berry, Halle', 'Berry, Wendell', 'Bethea, Erin', 'Bevan, Aneurin', 'Bevel, Ken', 'Biden, Joseph', 'Bierce, Ambrose', 'Biko, Steve', 'Billings, Josh', 'Biondo, Frank', 'Birrell, Augustine', 'Black, Elk', 'Blair, Robert', 'Blair, Tony', 'Blake, William'];

    // Array.prototype.filter()
    // 1. Filter the list of inventors for those who were born in the 1500's
    const oldest = inventors.filter(person => person.year >= 1500 && person.year < 1600); // My solution
    /* 
      (3) [{…}, {…}, {…}]
        0: {first: "Galileo", last: "Galilei", year: 1564, passed: 1642}
        1: {first: "Johannes", last: "Kepler", year: 1571, passed: 1630}
          length: 2
    */

    // Array.prototype.map()
    // 2. Give us an array of the inventors' first and last names
    const names = inventors.map(inventor => `${inventor.first} ${inventor.last}`); // My solution
    /* 
      (12) ["Albert Einstein", "Isaac Newton", "Galileo Galilei",
      "Marie Curie", "Johannes Kepler", "Nicolaus Copernicus", "Max Planck",
      "Katherine Blodgett", "Ada Lovelace", "Sarah E. Goode", "Lise Meitner",
      "Hanna Hammarström"]
    */

    // Array.prototype.sort()
    // 3. Sort the inventors by birth date, oldest to youngest
    const ageSorted = inventors.sort((a, b) => a.year - b.year); // My solution
    /*
      (12) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]
      0: {first: "Nicolaus", last: "Copernicus", year: 1473,...
      1: {first: "Galileo", last: "Galilei", year: 1564,...
      ...and so on to the youngest... 
    */

    // Use of the `compareFunction`
    /* 
      If compareFunction(a, b) is less than 0, sort a to an index lower than b
      (i.e. a comes first).

      If compareFunction(a, b) returns 0, leave a and b unchanged with respect
      to each other, but sorted with respect to all different elements. Note:
      the ECMAscript standard does not guarantee this behavior, and thus not
      all browsers (e.g. Mozilla versions dating back to at least 2003) respect
      this.

      If compareFunction(a, b) is greater than 0, sort b to an index lower than
      a (i.e. b comes first).

      compareFunction(a, b) must always return the same value when given a
      specific pair of elements a and b as its two arguments. If inconsistent
      results are returned then the sort order is undefined.
    */

    // Wes's initial solution
    const ordered = inventors.sort(function(a, b) {
      if (a.year > b.year) {
        return 1;
      } else {
        return -1;
      }
    });

    // Wes's refactored solution - using a ternary operator
    const orderedRefactor = inventors.sort((a, b) => a.year > b.year ? 1 : -1);

    // Array.prototype.reduce()
    // 4. How many years did all the inventors live?
    const totalYearsLived = inventors.reduce((acc, currentVal) => {
       return acc + (currentVal.passed - currentVal.year);
    }, 0); // initial val needed `0`
    /*
      861
    */

    // 5. Sort the inventors by years lived
    const oldestInventor = inventors.sort((a, b) => {
      const lastInventor = a.passed - a.year;
      const nextInventor = b.passed - b.year;
      return lastInventor > nextInventor ? -1 : 1; // Wes's solution
      // return nextInventor - lastInventor; // This also works
    });
    /*
      (12) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]
        0: {first: "Lise", last: "Meitner", year: 1878, passed: 1968}...
        1: {first: "Max", last: "Planck", year: 1858, passed: 1947}...
        2: {first: "Isaac", last: "Newton", year: 1643, passed...
        And so on...
    */

    // 6. create a list of Boulevards in Paris that contain 'de' anywhere in the name
    // https://en.wikipedia.org/wiki/Category:Boulevards_in_Paris

    // const category = document.querySelector(".mw-category")
    // const links = Array.from(category.querySelectorAll("a"));

    /* 
      Note: querySelectorAll can be called against any existing DOM element,
      not just the document.
      Also `Array.from(...) used to create an array from the returned 
      NodeList so `.map(...)` can be used.
    /*

    // const de = links
    //     .map(link => link.textContent)
    //     .filter(streetName => streetName.includes("de"));

    /* console.log(de);

      12) ["Boulevard de l'Amiral-Bruix", "Boulevard des Capucines", "Boulevard de la Chapelle", "Boulevard de Clichy", "Boulevard de l'Hôpital", "Boulevard des Italiens", "Boulevard de la Madeleine", "Boulevard de Magenta", "Boulevard de Rochechouart", "Boulevard de Sébastopol", "Boulevard de Strasbourg", "Boulevard de la Zone"]
        0: "Boulevard de l'Amiral-Bruix"
        1: "Boulevard des Capucines"
        2: "Boulevard de la Chapelle"
        And so on...
    */

    // 7. sort Exercise
    // Sort the people alphabetically by last name
    // ?? list is already sorted alphabetically by last name
    // Wes's solution
    const lastNameSort = people.sort((lastOne, nextOne) => {
      const [aLast, aFirst] = lastOne.split(", ");
      const [bLast, bFirst] = nextOne.split(", ");
      return aLast > bLast ? 1 : -1;
    }); 

    // 8. Reduce Exercise
    // Sum up the instances of each of these
    const data = ['car', 'car', 'truck', 'truck', 'bike', 'walk', 'car', 'van', 'bike', 'walk', 'car', 'van', 'car', 'truck' ];

    // My solution
    const tally = data.reduce((vehicles, vehicle) => {
      if (vehicle in vehicles) {
        vehicles[vehicle] += 1;
      } else {
        vehicles[vehicle] = 1;
      }
      return vehicles;
    }, {});
  /*
    {car: 5, truck: 3, bike: 2, walk: 2, van: 2}
  */

  // Wes's solution

  const transportation = data.reduce(function(obj, item) {
    if (!obj[item]) {
      obj[item] = 0;
    }
    obj[item]++;
    return obj;
  }, {});

  // So you start with an empty object. Then check to see if the item
  // exists in it. If not create it. If it does increment it by one. 
  // Return the object.

  </script>
</body>
</html>
